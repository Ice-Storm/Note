C++迭代器
=========

#种类

* 标准STL序列容器： vector、string、deque和list。
* 标准STL关联容器： set、multiset、map和multimap。
* 非标准序列容器： slist和rope。slist是一个单项链表，rope本质上是一个重型字符串。
* 非标准关联容器： hash_set、hash_multiset、hash_map和hash_multimap。
* 几种标准非STL容器： 包括数组、bitset、valarray、stack、queue和priority_queue

>注意：值得注意的是，数组可以和STL算法配合，因为指针也可以当作数组的迭代器使用。

#删除元素

如果想删除东西，记住remove算法后，要加上erase。

所谓删除算法，最终还是要调用成员函数去删除某个元素，但是因为remove并不知道它现在作用于哪个容器，所以remove算法不可能真的删除一个元素。

* remove   
    算法描述：查找的得到第一个元素的位置，然后从此位置开始遍历容器，将后面的元素依次前移，跳过和value相同值的元素，也就是说，所有和value相同值的元素都会被覆盖，而其他的元素都会依次前移。最后remove返回"指向最后一个   '有用'   元素的iterator",但是在remove算法过程中，并没有修改原容器的size,以及end()。但是从逻辑角度看，最后的[   从remove得到的iterator---_result,   容器的结尾end()   )   这个区间里面的元素已经没有意义了。所以这些元素不应该属于该容器了。remove算法能做的仅此而已，并没有删除这些无用的元素。    

    结论：移除容器里面的元素不应该使用remove算法，而是容器自己的方法erase()。

## vector

```cpp
vector<int> v;   

v.reserve(10);   

for (int i = 1; i <= 10; ++i) {

 v.push_back(i);

}

cout << v.size();   // 10

v[3] = v[5] = v[9] = 99; 

remove(v.begin(), v.end(), 99); 

//v.erase(remove(v.begin(),v.end(),99),v.end());

cout << v.size();   // 10！
```

## list

```cpp
list<int> listTest;
listTest.remove(99); //这个成员函数将真的删除元素，并且要比erase+remove高效
```

remove和remove_if之间的十分相似。

但unique行为也像remove。它用来从一个区间删除东西（邻近的重复值）而不用访问持有区间元素的容器。如果你真的要从容器中删除元素，你也必须成对调用unique和erase，unique在list中也类似于remove。正像list::remove真的删除东西（而且比erase-remove惯用法高效得多）。list::unique也真的删除邻近的重复值（也比erase-unique高效）。

坦白地说，调用这个remove函数是一个STL中的矛盾。在关联容器中类似的函数叫erase，list的remove也可以叫做erase。但它没有，所以我们都必须习惯它。我们所处于的世界不是所有可能中最好的世界，但却是我们所处的。（附加一点，条款44指出，对于list，调用remove成员函数比应用erase-remove惯用法更高效。）

# 迭代器失效

## vector

- 当插入（push_back）一个元素后，之前end操作返回的迭代器肯定失效。
- 当插入（push_back）一个元素后，capacity返回值如果发生改变，则说明容器重新申请了空间，则需要重新加载整个容器，此时first和end操作返回的迭代器都会失效。
- 当进行删除操作（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素迭代器也将全部失效。

## deque

- 在deque容器首部或者尾部插入元素不会使得任何迭代器失效。
- 在其首部或者尾部删除元素只会使得指向被删除元素的迭代器失效。
- 在deque容器的任何其他位置的插入和删除操作将使得指向该容器元素的所有迭代器失效。

## list/set/map

- 删除时，指向该节点的迭代器失效

```cpp
list<int> intList; 

list<int>::iterator it = intList.begin(); 

while(it != intList.end()) 

{ 

it = intList.erase(it); 

//…… 

}
```


# 选择时机

## vector

内部数据结构：数组。

随机访问每个元素，所需要的时间为常量。

在末尾增加或删除元素所需要时间与元素数目无关，在中间或者开头增加或删除元素所需要的时间随元素数目呈线性变化。

可动态增加或减少元素，内存管理自动完成，但程序员可以使用reserve()成员函数来管理内存。

vector的迭代器在内存重新分配时将失效（它所指向的元素在该操作的前后不再相同）。当把超过capacity-size()个元素插入vector中时，内存会重新分配，所有的迭代器豆浆失效；否则，指向当前元素以后的任何元素的迭代器都将失效。当删除元素时，指向被删除元素以后的任何元素的迭代器都将失效。

## deque

内部数据结构：数组。

随机访问每个元素，所需时间为常量。

可动态增加或者减少元素，内存管理自动完成，不提供用于内存管理的成员函数。

增加任何元素都将使deque的迭代器失效。在deque的中间删除元素将使所有迭代器失效。在deque的头或尾部删除元素时，只有指向该元素的迭代器失效。

## list

内部数据结构： 双向环状链表。

不能随机访问一个元素。

可双向遍历。

在开头、末尾和中间任何一个地方增加或者删除元素所需时间都为常量。

可动态增加或减少元素，内存管理自动完成。

增加任何元素都不会使迭代器失效。删除元素时，除了指向当前被删除元素的迭代器外，其他迭代器都不会失效。

##　slist

内部数据结构： 单向链表。

不可双向遍历，只能从前到后遍历。

其他特性同list相似。

## stack

适配器，它可以将任意类型的序列容器转换为一个堆栈，一般使用deque作为支持的序列容器。

容器只能后进先出（LIFO）

不能遍历整个stack。

##　queue

适配器，它可以将任意类型的哦序列容器转换为一个队列，一般使用deque最为支持的序列容器。

元素只能先进先出（FIFO） 

不能遍历整个queue。

## priority_queue

适配器，它可以将任意类型的序列容器转换为一个优先级队列，一般使用vector作为底层存储方式。

只能访问第一个元素，不能遍历整个priority_queue。

第一个元素始终是优先级最高的一个元素。

## set

键和值相等。

键唯一。

元素默认按升序排列。

如果迭代器所指向的元素被删除，则该迭代器失效。其他任何增加、删除元素的操作都不会使迭代器失效。

## multiset

键可以不唯一。

其他特点与set相同。

## hash_set

和set相比较，它里面的元素不一定是经过排序的，而是按照所用的hash函数分派的，它能提供更快的搜索速度（当然跟hash函数有关）。

其他特点与set相同。

## hash_multiset

键可以不唯一。

其他特点与hash_set相同。

## map

键唯一。

元素默认按键的升序排列。

如果迭代器所指向的元素被删除，则该迭代器失效。其他任何增加、删除元素的操作都不会使迭代器失效。

## multimap

键可以不唯一。

其他特点与map相同。

## hash_map

与map相比较，它里面的元素不一定是按键值排序的，而是按照所用的hash函数分派的，它能提供更快的搜索速度（当然也跟hash函数有关）。

其他特点与map相同。

## hash_mutimap

键可以不唯一。

其他特点与hash_map相同。


