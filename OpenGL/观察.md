观察
===
[TOC]

观察是OpenGL中很重要的一步。我们将会看到观察过程包括两个步骤。第一个步骤使用模-视变换矩阵把对象的顶点表示从对象标架变换到眼标架。对象是在对象标架中定义的，而照相机位于眼标架的原点。获得了几何对象在眼标架下的表示之后，就可以使用规范的观察过程。第二个步骤是指定想要的投影类型（平行投影或者透视投影）和视见体（或称为裁剪体，是场景中我们希望成像的那一部分）。投影类型和视见体确定了一个投影变化矩阵，该矩阵可以与模-视变换矩阵级联。

#经典观察和计算机观察
经典观察和计算机都包含对象、观察者、投影线和投影平面，投影线相交于投影中心（center of projection, COP）。COP对应于照相机中的透镜或者人眼中的晶状体，而在计算机图形系统中，对于透视投影而言，COP位于照相机标架的原点。所有图形系统都遵循以下规则，投影面是平面，并且投影线是直线。我们通常遇到的就是这种类型的投影，这类投影实现比较容易，利用绘制流水线模型来实现更是如此。

经典观察和计算机观察都允许观察者相距对象无穷远。注意，如果COP移到无穷远，则投影线会变成平行线，此时可以用投影方向（direction of projection, DOP）代替COP。还要注意当COP向无穷处移动时，我们可以把投影平面固定，这样所成的投影图大小基本不变，即使COP距离对象无穷远也是如此。如果COP在有限远处，那么生成的是透视投影图（perspective view）；如果COP在无限远处，那没生成的是平行投影图（parallel view）。对于平行投影，照相机表叫的原点通常位于投影平面。

#计算机观察
OpenGL的默认照相机位于对象标架的原点，方向指向z轴的负方向。该照相机生成的是正交投影图。默认视见体是中兴位于原点并且边长为2的立方体。默认的投影平面为z=0，投影方向沿着z轴。因此，在这个视见体内的对象是可见的，于是可以在投影平面上成像。

##定位照相机
指定顶点时可以选择任何单位，并且可以通过一系列重新定位这些顶点的仿射变换定义一个模-视变换矩阵。模-视变换矩阵是建模变换和观察变换的级联。建模变换把对象从对象标架变换到世界标架，而观察变换把世界坐标变换到照相机坐标。（标架的变换顺序相反）。因为我们通常不需要处理世界坐标，所以可以使用模-视变换矩阵，而不是分别使用建模矩阵和观察矩阵。

初始的模-视变换矩阵是单位阵，因此照相机标架和对象标架是重合的。在OpenGL中，初始照相机的方向是z轴的负方向。在大多数应用程序中，我们在原点附近建模对象，因此默认方位的照相机无法包含场景中全部对象的图像。这样，要么把照相机移走，使之远离我们希望成像的对象；要么把对象移到照相机的前面。这两个操作是等价的，因为它们都可以看做是在对象标架下指定照相机标架。

![initial-camera-position][1]

从应用程序控制流程的角度来看，投影变换矩阵和模-视变换矩阵都是状态的一部分，因此在定义一个图元的时候，系统当前的状态决定了要应用到这个图元上的矩阵。

当我们通过一系列变换把模-视变换矩阵变成C后，两个标架不再相同，但是C包含了从照相机标架移动到对象标架的信息，或者说，它包含了把照相机从其初始位置（对象标架的原点）移开的信息。这时，如果调用函数glVertex定义一个位于q处的顶点，则该顶点在对象标架下的表示为q，但它在照相机标架下的表示为Cq。OpenGL通过观察流水线把顶点变化到照相机标架中，并在内部保存顶点在照相机标架下的坐标。与之等价的看法是：照相机仍旧位于自己标架的原点，但对在这个标架下定义的图元要应用模-视变换矩阵。在实际编程时，可以采取这两种看法中的任何一种，但要特别小心对图元的定义是在模-视变换矩阵改变之前还是之后。

![movement-of-the-camera-and-object-frame][2]

考虑一个中心在原点的对象。照相机位于初始位置（也在原点），方向指向z轴负方向。入定相对这个对象朝着z轴正方向的那一面成像，那么必须把照相机从原点移走。如果照相机仍旧指向z轴的负方向，那么应该让照相机沿着z轴正方向后退，因此正确的变换是：

```c
glTranslatef(0.0, 0.0, -d);
```
其中d是一个正数。（相对照相机标架移动对象）

在OpenGL中，对于像glOrtho这样的函数，距离是从照相机出发来测量的，虽然这与经典视图一致，但OpenGL保持了右手照相机标架，和经典视图的左手标架不同。

假定我们想从x轴正半轴观察同一个对象。现在不但要把照相机从对象所在的位置移开，还要绕y轴旋转照相机。

```c
glMatrixMode(GL_MODELVIEW);
glLoadIndentity();
glTranslatef(0.0, 0.0, -d);
glRotatef(-90.0, 0.0, 1.0, 0.0);
```

从两个标架的角度看，我们先相对于照相机标架移动对象标架，然后相对于新的对象标架y轴旋转对象标架。
>注意，原书《交互式计算机图形学（第五版）》p184页中解释是先相对于照相机标架旋转对象标架，然后通过平移使这两个标架分离，是按相反的方向理解的，但是按笔者的理解，对于标架的变换应该顺着代码执行方向进行，对坐标系的变换才是按想法方向进行的，如有不对请指正。


![positioning-of-the-camera][3]

在OpenGL中，设置模-视变换矩阵的代码如下：

```c
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
glTranslatef(0.0, 0.0, -d);
glRotatef(35.26, 1.0, 0.0, 0.0);
glRotatef(45.0, 0.0, 1.0, 0.0);
```

>注意，由glOrtho设置的裁剪体是相对于照相机标架的。因此，对于正投影而言，照相机的平移不影响成像的大小，但会影响对象是否被裁剪。

以上代码提出了一个技巧，任何一个旋转可以分解成绕x，y，z的三个旋转，但要注意，以上代码的旋转每次是绕着当前新标架旋转，并不是绕着固定标架运动的，那如果想要绕着一个固定的标架运动该怎么办，这个时候可以从坐标变换的角度去考虑，每次变换都是在照相机标架下对新的坐标进行，但是顺序是从下到上，因此新的运动函数要添加到旧的运动函数的上面，可以考虑用堆栈，或者使用矩阵左乘实现（经实测有效，但要注意OpenGL下的矩阵是列主序的，取出来后进行运算时要统一存储方式，最后按照列主序传给OpenGL。注意，不要混淆存储方式和数学表达方式，相同序列，按列主序和行主序两种方法解析解析，一般获得的是两个不同的矩阵）。


##LookAt函数
 LookAt函数为我们提供了一个直接定位照相机的方法，考虑图中情况，其中照相机位于点e，该点称为视点(eye point)，是在建模标架下指定的，照相机的方向指向另一个点a，该点称为参考点（at point）。这两个点确定了VPN和VRP。对视点和参考点这两个点做减法，所得的向量就给出了VPN：
 
 	vpn = a - e
 	
因为观察参考点就是视点，所以只需要再对照相机指定想要的观察正向。OpenGL的glu工具库提供了下面的函数：

```c
void gluLookAt(
		GLdouble eyex, GLdouble eyey, GLdouble eyez,/*视点*/
		GLdouble atx, GLdouble aty, GLdouble atx,   /*参考点*/
		GLdouble upx, GLdouble upy, GLdouble upz    /*观察正向*/
        );  
```

利用这个函数就可以定位照相机，因此通常使用下面的代码：
	
```c
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
gluLookAt(eyex, eyey, eyez,
			atx, aty, atz,
			upx, upy, upz);
/*这里是定义对象的代码*/
```
注意，我们可以把标准的旋转、平移和缩放作为定义对象的一部分。尽管这些变换也会改变模-视变化矩阵，但可以认为：

	gluLookAt是在定位照相机，而接下来影响模-视变换矩阵的哪些操作是在定位对象，采取这样的看法常常会在概念上带来方便。
	也可以认为是LookAt函数把世界标架相对照相机标架进行定位，照相机标架本身没动，之后的对象都是在世界标架上定义。


#简单的投影
对于实际的照相机，在确定它的方向之后还必须选择透镜。是透镜和胶片的尺寸（或者照相机后面的大小）共同决定了在照相机面前的场景中有多大部分被成像。与此等价，在计算机图形学中可以选择投影类型和观察参数。

##透视投影

![oblique-projection][5]

根据投影中的相似三角形，可以得出一系列比例关系

	x/z = xp / d
	xp = x / (z/d)

这些方程是非线性的，用z去除导致了非均匀的透视缩短（nonumform foreshortening）：对象离投影中心越远，所成的像就越小。

我们可以把投影过程看做是一个变换，它把点（x，y，z）映射成了另一个点（xp，yp，zp）。尽管这种透视变换（perpective transformation）把直线仍变换成直线，但它不是仿射变换。透视变换也是不可逆的：因为一条投影线上的所有点都会投影到同一个点我们不能从一个点的投影回复出这个点。

齐次坐标也可以用于投影变换，使用坐标中的第四位可以达到缩放的效果。
第四位不仅仅是0和1，还能是其他值，最后去除其他三个分量，把第四位用于透视除法。

![projecton-pipeline][6]

##正交投影
正交投影或者说正投影（orthographic projection）是平行投影的一种特殊情形：正交投影的投影线垂直于观察平面。


#OpenGL中的投影
在大多数API中，指定投影函数的同时也指定裁剪参数。如果除了视角以外，再增加前裁剪面和后裁剪面，那么就得到了一个有限的裁剪体。一般情况下投影面可以想象成是近剪裁面。

在OpenGL中，定位照相机的函数（如glLookAt函数）会改变模-视变换矩阵并且其参数是建模坐标给出的，而现在要介绍的函数将改变投影变换矩阵，这些函数的参数要用观察坐标给出。


##OpenGL中的透视投影
由函数glFrustum确定的投影变换矩阵将和当前的矩阵相乘，因此必须先选择矩阵模式。典型的代码如下：

```c
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
glFrustum(left, right, bottom, top, near, far);
```
注意，这些参数不一定非要关于z轴对称，near和far的正负也需要注意。

![specification-of-a-frustum][7]

OpenGL工具库中还提供一个更方便的函数：

```c
gluPerspective(GLdouble, fovy, GLdouble aspect,
		GLdouble near, GLdouble far)
```

允许用户指定沿y轴方向的视角和投影平面的宽高比。由这个函数确定的投影矩阵也会改变当前矩阵所以在调用这个函数之前也的选择矩阵模式，并且通常要加载单位矩阵。

##OpenGL中的平行投影
OpenGL提供的唯一一个平行投影观察函数是正交投影观察函数：

```c
glOrtho(GLdouble left, GLdouble right, GLdouble bottom, 
	GLdouble top,  GLdouble near, GLdouble far)
```

>注意，glOrtho函数并不一定要和z轴对称，它可以在任何位置，只是一定平行与坐标轴，投影面在近剪切面，

##规范视见体
OpenGL中为了更好的发挥流水线的性能，对透视投影和正投影都采用了先进行规范视见体变换，最后再进行正投影的过程，这样两种投影方式都能变成正投影。规范视见体是由以下平面所定义的立方体：

    x +- 1
    y +- 1
    z +- 1

规范体还简化了裁剪过程因为它们的各面和相应的坐标轴分别平行。

#隐藏面消除
OpenGL实现了一种特定的算法，即z缓存算法（z-buffer algorithm），并为用户提供了三个函数。我们能够保留在每条投影线上从COP或者投影平面到已经绘制的最近点的距离，就能在投影和填充随后绘制的多边形时更新这个信息。最终结果是：我们只显示每条投影线上最近的点。为了在光栅化多边形时存储必要的深度信息，该算法需要一个深度缓存（depth buffer）或者称为z缓存（z buffer）。这个算法的主要优点是：它的复杂度正比于光栅化生成的片元数量。

```c
gluInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
glEnable(GL_DEPTH_TEST);

glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//清楚颜色缓存和深度缓存
```

#背面剔除
像立方体这样的凸对象，法线方向背离观察者的面总是不可见的，因此可以在光栅化之前（也就是在隐藏面消除前）将其剔除掉，我们可以在OpenGL中调用下面的函数来开启背面剔除功能：

```c
glEnable(GL_CULL);
```
然而，背面剔除只有对凸对象才能得到正确的图像。我们经常在使用z缓存算法（对任何多边形都有效）的同时还使用背面剔除。例如对n个立方体开启背面剔除，原来流水线需要处理6n个多边形，开启剔除功能后，一半多边形在流水线初期被剔除，因此只有3n个多边形需要经过绘制流水线全部阶段的处理。



[1]: images/initial-camera-position.png
[2]: images/movement-of-the-camera-and-object-frame.png
[3]: images/positioning-of-the-camera.png
[4]: images/look-at-positioning.png
[5]: images/three-views-of-perspective-projection.png
[6]: images/projecton-pipeline.png
[7]: images/specification-of-a-frustum.png