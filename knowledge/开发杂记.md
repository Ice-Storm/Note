开发杂记
========

1. 当开发一个新的软件时，为了减小对当前开发环境的影响，软件中任何对开发环境有副作用的操作最好先通过模拟的方式实现，比如可以通过printf等方法先通过测试，确定没有问题之后再开始进行真正的操作，这样可以防止影响当前系统正常工作。

#调试
长时间调试找不到错误的时候，可能错误就在眼皮底下自己没有注意到，这时最好找其他人帮忙找或者休息一下，干点其他事，分散下注意力，否则调试容易走进死胡同，反而浪费时间。

#浮点数
* NaN (not a number)
* Inf (INFINITE）

acos()等函数中参数值绝对值大于1时，会返回NaN。

在调试浮点数的时候，debug和终端输出的值并不是真实的值，如果需要，直接在代码中使用浮点变量进行迭代计算和调试，而不要使用看到的具体数值替代，那会损失精度造成调试结果错误。

#标准
标准就常常被说成『在程序员和语言实现者之间的一个协议』，它不仅要描述什么是『合法的』源代码正文，还要一般性的说明程序员可以依赖什么，哪些东西将是与具体实现有关的。例如，在C和C++中可以将一个变量声明为int类型，但是标准就没有明确说明int到底有多大，而只是说明它至少应该有16位。

标准对什么是、什么不是合法程序做出一种明确划分，并进一步规定，哪些行为应该在所有的实现中应该一致，而哪些应该依赖于具体的实现。 

#移植性
同一个系统下两个不同的C编译器生成的代码不能保证连接到一起。

#扩展性
设计时需要考虑系统将来的扩展性，选择数值范围的时候要具有前瞻性，在性能范围内可以选择较大的数值范围，避免将来需要的数据超过数值范围。

#链接错误
程序修改后 make 产生链接错误，是 makefile 有问题吗？猜想是编译时进行了优化，一些没有被使用的函数没有编译进程序，修改后对哪些函数进行了引用，由于根据 makefile 规则，那些文件不需要更新，所以产生链接错误。

#C++的教与学
>首先强调一些概念，随后再强调概念之间的关系和主要的语言特征。把各个单独语言特征的细节先放下，知道人们需要知道他们的时候再去学习。在这个方式行不通的地方，就设法修改语言去支持它。这种相互作用，使这一语言逐渐成长为一种适用与设计的更好的工具。

#C++的引用
C++的引用是一个很方便的特性，但是和指针的使用上有点差别。不能像指针一样重复使用一个引用，如

```c
int a = 0
int &b = a;
b = 2;  // a = 2
int c = 3;
b = c;  // a = c = 3，b 仍然绑定 a，而不会变成绑定 c，这里具有迷惑性，很容易产生 bug。
b = 4;  // a = 4
```

#C++成员函数中的静态变量
成员函数中的静态变量属于类，所有对象共享一个静态变量，由于该变量在成员函数中，因此具有迷惑性，常会以为每个对象都有一份该静态变量，实际上成员函数代码只有一份，由类保管，对象使用时传递 this 指针给函数，使得函数内部的环境变成好像在对象内部一样，因此成员函数内的静态对象也只有一份。		
>**请注意,C++ 局部静态初始化不是线程安全!**

**类函数中的静态类实例允许使用私有构造函数和私有析构函数，因此可以在这里创建单实例，并在程序结束时由系统析构；** 而在类外部无法调用私有构造函数和私有析构函数，因此会在构造实例或析构实例时出错。

#禁止 Copy
It declares a copy constructor and an assignment operator in the private section, so that if you use them by mistake, the compiler will report an error.

```cpp
class MyClass : public QObject
{

  private:
     MyClass(const MyClass &);
     MyClass &operator=(const MyClass &);
};
```

But even this might not catch absolutely every case. You might be tempted to do something like this:

```cpp
  QWidget w = QWidget();
```
会出现这种情况的原因是 C++11 引入了 move 构造函数，如果有 public 的 move 构造函数，该情况就会发生。
>**另外,编译器永远不会自动生成move版本的构造函数和赋值函数, 它们需要你手动添加**

```cpp
MyClasss(const MyClass &&);
```
如果使用 C++11 编译器，move 构造函数会被使用。
move 


# 具体操作
1. 画框图
2. 代码精简，先完成必要功能，不要添加多余方法和属性。
3. 熟练使用设计模式。
4. 边写项目，边进行单元测试，即有助于保证代码的正确性，并去除多余的方法和属性，也能尽早让代码通过编译，抛弃不可能实现的写法。
5. 所有的函数和方法都需要有一定调用的前提保证，如保证传递的参数一定正确，传递的指针一定有效等，这样才能简化代码和思路，写出高效的方法。**在这种情况下，代码可以使用断言，方便出现意外的时候查错。**
6. 段错误常常是由空指针引起的，而这个需要在单步的时候仔细思考查看。
7. 浮点数不要使用==，用做差的方法，当差足够小时认为相等。
8. 编译连接遇到错误，可以尝试提取部分内容出来单独进行编译，每次编译一小部分，对比两边定位问题位置。
9. 任何试图从智能指针内部取出成员单独使用的操作都有可能产生错误。